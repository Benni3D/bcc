test/cases.h:175:   .name = "extern-var",
test/cases.h:495:   .name = "addr-of union-member",
src/i386/gen.c:14:   switch (n->type) {
src/i386/gen.c:17:      return n->next;
src/i386/gen.c:22:      reg_op(dest, n->move.dest, n->move.size);
src/i386/gen.c:23:      reg_op(src, n->move.src, n->move.size);
src/i386/gen.c:26:      return n->next;
src/i386/gen.c:31:      reg_op(dest, n->load.dest, n->load.size);
src/i386/gen.c:32:      if (!n->load.value) emit_clear(dest);
src/i386/gen.c:33:      else emit("mov %s, %jd", dest, (intmax_t)n->load.value);
src/i386/gen.c:34:      return n->next;
src/i386/gen.c:39:      const char* a = irv2str(&n->binary.a, n->binary.size);
src/i386/gen.c:40:      const char* b = irv2str(&n->binary.b, n->binary.size);
src/i386/gen.c:42:      reg_op(dest, n->binary.dest, n->binary.size);
src/i386/gen.c:44:      if (n->binary.a.type == IRT_REG && n->binary.dest == n->binary.a.reg) {
src/i386/gen.c:45:         if (n->binary.b.type == IRT_UINT && n->binary.b.uVal == 1) {
src/i386/gen.c:46:            emit("%s %s", (n->type == IR_IADD ? "inc" : "dec"), dest);
src/i386/gen.c:47:         } else emit("%s %s, %s", (n->type == IR_IADD ? "add" : "sub"), dest, b);
src/i386/gen.c:49:         emit("lea %s, [%s %c %s]", dest, a, (n->type == IR_IADD ? '+' : '-'), b);
src/i386/gen.c:51:      return n->next;
src/i386/gen.c:72:      const char* a = irv2str(&n->binary.a, n->binary.size);
src/i386/gen.c:73:      const char* b = irv2str(&n->binary.b, n->binary.size);
src/i386/gen.c:75:      reg_op(dest, n->binary.dest, n->binary.size);
src/i386/gen.c:77:      if (n->binary.a.type != IRT_REG || n->binary.dest != n->binary.a.reg) {
src/i386/gen.c:81:      return n->next;
src/i386/gen.c:91:      reg_op(reg, n->unary.reg, n->unary.size);
src/i386/gen.c:93:      return n->next;
src/i386/gen.c:114:      const char* a = irv2str(&n->binary.a, IRS_PTR);
src/i386/gen.c:115:      const char* b = irv2str(&n->binary.b, IRS_PTR);
src/i386/gen.c:116:      if (n->binary.dest != 0) emit("push %s", reg_ax);
src/i386/gen.c:118:      snprintf(f, sizeof(f), "__%s%ci%zu", instr + 1, *instr, irs2sz(n->binary.size) * 8);
src/i386/gen.c:126:      if (n->binary.dest != 0) {
src/i386/gen.c:127:         emit("mov %s, %s", mreg(n->binary.dest), reg_ax);
src/i386/gen.c:133:      return n->next;
src/i386/gen.c:139:      return n->next;
src/i386/gen.c:143:      return n->next;
src/i386/gen.c:147:      const char* src =  mreg(n->move.src);
src/i386/gen.c:148:      reg_op(dest, n->move.dest, n->move.size);
src/i386/gen.c:149:      emit("mov %s, %s [%s]", dest, nasm_size(n->move.size), src);
src/i386/gen.c:150:      return n->next;
src/i386/gen.c:154:      const char* dest = mreg(n->move.dest);;
src/i386/gen.c:156:      reg_op(src, n->move.src, n->move.size);
src/i386/gen.c:157:      emit("mov %s [%s], %s", nasm_size(n->move.size), dest, src);
src/i386/gen.c:158:      return n->next;
src/i386/gen.c:162:      buf_push(defined, n->func->name);
src/i386/gen.c:163:      if (!(n->func->attrs & ATTR_STATIC))
src/i386/gen.c:164:         emit("global %s", n->func->name);
src/i386/gen.c:165:      emit("%s:", n->func->name);
src/i386/gen.c:178:      for (size_t i = 0; i < my_min(buf_len(n->func->params), arraylen(param_regs)); ++i) {
src/i386/gen.c:184:      const size_t sz = align_stack_size(sizeof_scope(n->func->scope));
src/i386/gen.c:187:      assign_scope(n->func->scope, &addr);
src/i386/gen.c:190:      return n->next;
src/i386/gen.c:193:      if (strcmp(n->func->name, "main") == 0 && n->prev && n->prev->prev && n->prev->prev->type != IR_IRET)
src/i386/gen.c:198:      return n->next;
src/i386/gen.c:200:      if (n->unary.reg != 0) {
src/i386/gen.c:203:         reg_op(reg, n->unary.reg, n->unary.size);
src/i386/gen.c:204:         reg_op(eax, 0, n->unary.size);
src/i386/gen.c:210:      //if (n->next && n->next->type != IR_END_SCOPE && n->next->next && n->next->next->type == IR_EPILOGUE)
src/i386/gen.c:212:      return n->next;
src/i386/gen.c:215:      if (n->iicast.ds < n->iicast.ss) {
src/i386/gen.c:216:         if (n->iicast.dest != n->iicast.src) {
src/i386/gen.c:219:            reg_op(dest, n->iicast.dest, n->iicast.ds);
src/i386/gen.c:220:            reg_op(src, n->iicast.src, n->iicast.ds);
src/i386/gen.c:224:            switch (n->iicast.ds) {
src/i386/gen.c:230:               emit("mov %s, %s", reg32(n->iicast.dest), reg32(n->iicast.dest));
src/i386/gen.c:235:            if (mask) emit("and %s, 0x%jx", mreg(n->iicast.dest), (uintmax_t)mask);
src/i386/gen.c:237:      } else if (n->iicast.ds > n->iicast.ss) {
src/i386/gen.c:240:         if (n->iicast.ds != IRS_LONG && n->iicast.ds != IRS_PTR) {
src/i386/gen.c:241:            reg_op(dest, n->iicast.dest, n->iicast.ds);
src/i386/gen.c:242:            reg_op(src, n->iicast.src, n->iicast.ss);
src/i386/gen.c:243:            emit("%s %s, %s", n->iicast.sign_extend ? "movsx" : "movzx", dest, src);
src/i386/gen.c:246:         if (n->iicast.dest != n->iicast.src) {
src/i386/gen.c:249:            reg_op(dest, n->iicast.dest, n->iicast.ds);
src/i386/gen.c:250:            reg_op(src, n->iicast.src, n->iicast.ds);
src/i386/gen.c:254:      return n->next;
src/i386/gen.c:259:      const size_t np = buf_len(n->ifcall.params);
src/i386/gen.c:262:      for (i = 0; i < n->ifcall.dest; ++i) {
src/i386/gen.c:277:            ir_node_t* tmp = n->ifcall.params[i - 1];
src/i386/gen.c:279:            emit("push %s", mreg(n->ifcall.dest));
src/i386/gen.c:283:         ir_node_t* tmp = n->ifcall.params[i];
src/i386/gen.c:286:            emit("mov %s, %s", mreg(param_regs[i]), mreg(n->ifcall.dest));
src/i386/gen.c:289:         else emit("push %s", mreg(n->ifcall.dest));
src/i386/gen.c:296:         if (n->ifcall.name == cunit.funcs[i]->name) {
src/i386/gen.c:302:      if (is_defined(n->ifcall.name)) emit("call %s", n->ifcall.name);
src/i386/gen.c:304:         emit("call [rel %s wrt ..got]", n->ifcall.name);
src/i386/gen.c:312:         ir_node_t* tmp = n->ifcall.params[i - 1];
src/i386/gen.c:314:         emit("push %s", mreg(n->ifcall.dest));
src/i386/gen.c:316:      emit("call %s", n->ifcall.name);
src/i386/gen.c:319:      if (!is_defined(n->ifcall.name))
src/i386/gen.c:320:         add_unresolved(n->ifcall.name);
src/i386/gen.c:321:      if (n->ifcall.dest != 0 && n->type != IR_FCALL) {
src/i386/gen.c:322:         emit("mov %s, %s", mreg(n->ifcall.dest), reg_ax);
src/i386/gen.c:324:      for (size_t i = n->ifcall.dest; i != 0; --i) {
src/i386/gen.c:328:      return n->next;
src/i386/gen.c:332:      size_t idx = n->lookup.scope->vars[n->lookup.var_idx].addr;
src/i386/gen.c:338:         if (ir_is(n->next, IR_READ) && n->next->move.src == n->lookup.reg) {
src/i386/gen.c:339:            ir_node_t* read = n->next;
src/i386/gen.c:343:               if (ir_is(inc->next, IR_WRITE) && inc->next->move.src == inc->binary.dest && inc->next->move.dest == n->lookup.reg) {
src/i386/gen.c:361:            reg_op(dest, n->next->move.dest, read->move.size);
src/i386/gen.c:364:         } else if (ir_is(n->next, IR_WRITE) && n->next->move.dest == n->lookup.reg) {
src/i386/gen.c:365:            ir_node_t* write = n->next;
src/i386/gen.c:373:      emit("lea %s, [%s - %zu]", mreg(n->lookup.reg), reg_bp, idx);
src/i386/gen.c:374:      return n->next;
src/i386/gen.c:379:      if (n->fparam.reg < arraylen(param_regs)) {
src/i386/gen.c:380:         emit("lea %s, [%s - %u]", mreg(n->fparam.reg), reg_bp, REGSIZE * (n->fparam.idx + 1));
src/i386/gen.c:382:         emit("lea %s, [%s + %u]", mreg(n->fparam.reg), reg_bp, REGSIZE * (n->fparam.idx + 2 - arraylen(param_regs)));
src/i386/gen.c:385:      emit("lea %s, [%s + %u]", mreg(n->fparam.reg), reg_bp, REGSIZE * (n->fparam.idx + 2));
src/i386/gen.c:387:      return n->next;
src/i386/gen.c:392:      strdb_add(n->lstr.str, &ptr);
src/i386/gen.c:394:      emit("lea %s, [rel __strings + %zu]", mreg(n->lstr.reg), ptr->idx);
src/i386/gen.c:396:      emit("lea %s, [__strings + %zu]", mreg(n->lstr.reg), ptr->idx);
src/i386/gen.c:398:      return n->next;
src/i386/gen.c:429:      const char* a = irv2str(&n->binary.a, n->binary.size);
src/i386/gen.c:430:      const char* b = irv2str(&n->binary.b, n->binary.size);
src/i386/gen.c:431:      reg_op(dest, n->binary.dest, n->binary.size);
src/i386/gen.c:434:      if (optim_level >= 1 && n->next && (n->next->type == IR_JMPIF || n->next->type == IR_JMPIFN)
src/i386/gen.c:435:            && n->binary.dest == n->next->cjmp.reg) {
src/i386/gen.c:437:         if (n->next->type == IR_JMPIF)
src/i386/gen.c:438:            instr = es[n->type].jmp;
src/i386/gen.c:439:         else instr = es[es[n->type].negation].jmp;
src/i386/gen.c:440:         emit("%s %s", instr, n->next->str);
src/i386/gen.c:441:         return n->next->next;
src/i386/gen.c:443:         emit("%s %s", es[n->type].set, reg8(n->binary.dest));
src/i386/gen.c:444:         if (n->binary.size > IRS_CHAR)
src/i386/gen.c:445:            emit("movzx %s, %s", dest, reg8(n->binary.dest));
src/i386/gen.c:446:         return n->next;
src/i386/gen.c:450:      emit("%s:", n->str);
src/i386/gen.c:451:      return n->next;
src/i386/gen.c:453:      emit("jmp %s", n->str);
src/i386/gen.c:454:      return n->next;
src/i386/gen.c:463:      reg_op(reg, n->cjmp.reg, n->cjmp.size);
src/i386/gen.c:465:      emit("%s %s", instr, n->cjmp.label);
src/i386/gen.c:466:      return n->next;
src/i386/gen.c:472:      const char* num = irv2str(&n->alloca.size, IRS_PTR);
src/i386/gen.c:473:      reg_op(dest, n->alloca.dest, IRS_PTR);
src/i386/gen.c:475:      e.is_const = n->alloca.size.type == IRT_UINT;
src/i386/gen.c:478:      if (e.is_const) e.sz = n->alloca.size.uVal;
src/i386/gen.c:480:         e.sz = n->alloca.var->addr + REGSIZE;
src/i386/gen.c:486:      return n->next;
src/i386/gen.c:490:      emit("mov %s, %s [%s - %zu]", mreg(n->lookup.reg), nasm_size(IRS_PTR),
src/i386/gen.c:491:            reg_bp, n->lookup.scope->vars[n->lookup.var_idx].addr + REGSIZE);
src/i386/gen.c:492:      return n->next;
src/i386/gen.c:499:      emit("mov %s, %s", mreg(param_regs[1]), mreg(n->copy.src));
src/i386/gen.c:500:      emit("mov %s, %s", mreg(param_regs[0]), mreg(n->copy.dest));
src/i386/gen.c:501:      emit("mov %s, %ju", mreg(param_regs[2]), n->copy.len);
src/i386/gen.c:508:      emit("push %ju", n->copy.len);
src/i386/gen.c:509:      emit("push %s", mreg(n->copy.src));
src/i386/gen.c:510:      emit("push %s", mreg(n->copy.dest));
src/i386/gen.c:515:      return n->next;
src/i386/gen.c:518:      emit("mov %s, %s", mreg(n->lstr.reg), n->lstr.str);
src/i386/gen.c:519:      if (!is_defined(n->lstr.str))
src/i386/gen.c:520:         add_unresolved(n->lstr.str);
src/i386/gen.c:521:      return n->next;
src/i386/gen.c:523:      emit("lea %s, [%s]", mreg(n->lstr.reg), n->lstr.str);
src/i386/gen.c:524:      return n->next;
src/i386/gen.c:529:      reg_op(reg, n->unary.reg, n->unary.size);
src/i386/gen.c:530:      reg_op(lower, n->unary.reg, IRS_BYTE);
src/i386/gen.c:533:      if (n->unary.size > IRS_CHAR)
src/i386/gen.c:535:      return n->next;
src/i386/gen.c:540:      const size_t np = buf_len(n->rcall.params);
src/i386/gen.c:545:      for (i = 0; i < n->rcall.dest; ++i) {
src/i386/gen.c:560:            ir_node_t* tmp = n->rcall.params[i - 1];
src/i386/gen.c:562:            emit("push %s", mreg(n->rcall.dest));
src/i386/gen.c:566:         ir_node_t* tmp = n->rcall.params[i];
src/i386/gen.c:569:            emit("mov %s, %s", mreg(param_regs[i]), mreg(n->rcall.dest));
src/i386/gen.c:572:         else emit("push %s", mreg(n->rcall.dest));
src/i386/gen.c:576:         ir_node_t* tmp = n->rcall.params[i - 1];
src/i386/gen.c:578:         emit("push %s", mreg(n->rcall.dest));
src/i386/gen.c:582:      ir_node_t* tmp = n->rcall.addr;
src/i386/gen.c:586:      emit("mov %s, %s", reg_bx, mreg(n->rcall.dest));
src/i386/gen.c:591:      if (n->rcall.variadic) emit_clear(reg_ax);
src/i386/gen.c:598:      emit("call %s", mreg(n->rcall.dest));
src/i386/gen.c:601:      if (n->rcall.dest != 0 && n->type != IR_FCALL) {
src/i386/gen.c:602:         emit("mov %s, %s", mreg(n->rcall.dest), reg_ax);
src/i386/gen.c:604:      for (size_t i = n->rcall.dest; i != 0; --i) {
src/i386/gen.c:610:      return n->next;
src/i386/gen.c:613:   default: panic("unsupported ir_node type '%s'", ir_node_type_str[n->type]);
src/optim_ir.c:13:      else n = n->next;
src/riscv32/emit_ir.c:16:   switch (n->type) {
src/riscv32/emit_ir.c:19:      return n->next;
src/riscv32/emit_ir.c:21:      emit("mv   %s, %s", reg_op(n->move.dest), reg_op(n->move.src));
src/riscv32/emit_ir.c:22:      return n->next;
src/riscv32/emit_ir.c:24:      emit("li   %s, %jd", reg_op(n->load.dest), (intmax_t)n->load.value);
src/riscv32/emit_ir.c:25:      return n->next;
src/riscv32/emit_ir.c:61:         av = n->binary.b;
src/riscv32/emit_ir.c:62:         bv = n->binary.a;
src/riscv32/emit_ir.c:64:         av = n->binary.a;
src/riscv32/emit_ir.c:65:         bv = n->binary.b;
src/riscv32/emit_ir.c:71:         a = reg_op(n->binary.dest);
src/riscv32/emit_ir.c:76:            reg_op(n->binary.dest),
src/riscv32/emit_ir.c:81:            reg_op(n->binary.dest),
src/riscv32/emit_ir.c:85:      return n->next;
src/riscv32/emit_ir.c:89:      return n->next;
src/riscv32/emit_ir.c:92:      return n->next;
src/riscv32/emit_ir.c:95:      ir_node_t* next = n->next;
src/riscv32/emit_ir.c:96:      ir_reg_t dest = n->move.dest;
src/riscv32/emit_ir.c:100:         && n->move.dest == next->iicast.src) {
src/riscv32/emit_ir.c:105:      switch (n->move.size) {
src/riscv32/emit_ir.c:112:      default:          panic("unsupported operand size '%s'", ir_size_str[n->move.size]);
src/riscv32/emit_ir.c:114:      emit("%s %s, 0(%s)", instr, reg_op(dest), reg_op(n->move.src));
src/riscv32/emit_ir.c:118:      switch (n->move.size) {
src/riscv32/emit_ir.c:125:      default:          panic("unsupported operand size '%s'", ir_size_str[n->move.size]);
src/riscv32/emit_ir.c:127:      emit("%s %s, 0(%s)", instr, reg_op(n->move.src), reg_op(n->move.dest));
src/riscv32/emit_ir.c:128:      return n->next;
src/riscv32/emit_ir.c:131:      func_name = n->func->name;
src/riscv32/emit_ir.c:132:      if (!(n->func->attrs & ATTR_STATIC))
src/riscv32/emit_ir.c:137:      const size_t num_reg_params = my_min(8, buf_len(n->func->params));
src/riscv32/emit_ir.c:138:      size_stack = sizeof_scope(n->func->scope);
src/riscv32/emit_ir.c:152:      assign_scope(n->func->scope, &sp);
src/riscv32/emit_ir.c:154:      return n->next;
src/riscv32/emit_ir.c:157:      if (!strcmp(n->func->name, "main"))
src/riscv32/emit_ir.c:159:      emit("%s.ret:", n->func->name);
src/riscv32/emit_ir.c:164:      return n->next;
src/riscv32/emit_ir.c:167:      if (n->unary.reg != 0) {
src/riscv32/emit_ir.c:168:         emit("mv   a0, %s", reg_op(n->unary.reg));
src/riscv32/emit_ir.c:173:      return n->next;
src/riscv32/emit_ir.c:175:      emit("%s:", n->str);
src/riscv32/emit_ir.c:176:      return n->next;
src/riscv32/emit_ir.c:178:      emit("j    %s", n->str);
src/riscv32/emit_ir.c:179:      return n->next;
src/riscv32/emit_ir.c:186:      emit("%s %s, x0, %s", instr, n->cjmp.reg, n->cjmp.label);
src/riscv32/emit_ir.c:187:      return n->next;
src/riscv32/emit_ir.c:190:      emit("la   %s, %s", reg_op(n->lstr.reg), n->lstr.str);
src/riscv32/emit_ir.c:191:      return n->next;
src/riscv32/emit_ir.c:194:      size_t addr = n->lookup.scope->vars[n->lookup.var_idx].addr;
src/riscv32/emit_ir.c:195:      emit("addi %s, fp, -%zu", reg_op(n->lookup.reg), addr);
src/riscv32/emit_ir.c:196:      return n->next;
src/riscv32/emit_ir.c:199:      return n->next;
src/riscv32/emit_ir.c:203:      strdb_add(n->lstr.str, &ptr);
src/riscv32/emit_ir.c:204:      emit("la   %s, __strings + %zu", reg_op(n->lstr.reg), ptr->idx);
src/riscv32/emit_ir.c:205:      return n->next;
src/riscv32/emit_ir.c:208:      if (n->fparam.idx < 8) {
src/riscv32/emit_ir.c:209:         emit("addi %s, fp, -%zu", reg_op(n->fparam.reg), 12 + n->fparam.idx * REGSIZE);
src/riscv32/emit_ir.c:214:      return n->next;
src/riscv32/emit_ir.c:216:      emit("sub %s, x0, %s", reg_op(n->unary.reg), reg_op(n->unary.reg));
src/riscv32/emit_ir.c:217:      return n->next;
src/riscv32/emit_ir.c:219:      emit("not %s, %s", reg_op(n->unary.reg), reg_op(n->unary.reg));
src/riscv32/emit_ir.c:220:      return n->next;
src/riscv32/emit_ir.c:222:      emit("seqz %s, %s", reg_op(n->unary.reg), reg_op(n->unary.reg));
src/riscv32/emit_ir.c:223:      return n->next;
src/riscv32/emit_ir.c:231:      const char* dest = reg_op(n->binary.dest);
src/riscv32/emit_ir.c:233:      if (n->binary.a.type == IRT_REG) {
src/riscv32/emit_ir.c:234:         a = reg_op(n->binary.a.reg);
src/riscv32/emit_ir.c:236:         a = reg_op(n->binary.dest);
src/riscv32/emit_ir.c:237:         emit("li %s, %jd", a, n->binary.b.sVal);
src/riscv32/emit_ir.c:239:      if (n->binary.b.type == IRT_REG) {
src/riscv32/emit_ir.c:240:         emit("sub %s, %s, %s", dest, a, reg_op(n->binary.b.reg));
src/riscv32/emit_ir.c:242:         emit("sub %s, %s, %jd", dest, a, n->binary.b.sVal);
src/riscv32/emit_ir.c:245:      return n->next;
src/riscv32/emit_ir.c:261:         av = n->binary.b;
src/riscv32/emit_ir.c:262:         bv = n->binary.a;
src/riscv32/emit_ir.c:264:         av = n->binary.a;
src/riscv32/emit_ir.c:265:         bv = n->binary.b;
src/riscv32/emit_ir.c:267:      const char* dest = reg_op(n->binary.dest);
src/riscv32/emit_ir.c:281:      return n->next;
src/riscv32/emit_ir.c:288:      const char* dest = reg_op(n->binary.dest);
src/riscv32/emit_ir.c:291:         av = n->binary.b;
src/riscv32/emit_ir.c:292:         bv = n->binary.a;
src/riscv32/emit_ir.c:294:         av = n->binary.a;
src/riscv32/emit_ir.c:295:         bv = n->binary.b;
src/riscv32/emit_ir.c:309:      return n->next;
src/riscv32/emit_ir.c:313:      const char* dest = reg_op(n->iicast.dest);
src/riscv32/emit_ir.c:314:      const char* src = reg_op(n->iicast.src);
src/riscv32/emit_ir.c:315:      if (n->iicast.ds == n->iicast.ss) {
src/riscv32/emit_ir.c:316:         if (n->iicast.dest != n->iicast.src)
src/riscv32/emit_ir.c:318:      } else if (n->iicast.ds < n->iicast.ss) {
src/riscv32/emit_ir.c:319:         switch (n->iicast.ss) {
src/riscv32/emit_ir.c:332:         if (n->iicast.sign_extend) {
src/riscv32/emit_ir.c:337:      return n->next;
src/riscv32/emit_ir.c:354:      ir_reg_t dest = flag ? n->rcall.dest : n->ifcall.dest;
src/riscv32/emit_ir.c:355:      const size_t np = buf_len(flag ? n->rcall.params : n->ifcall.params);
src/riscv32/emit_ir.c:356:      struct ir_node** params = flag ? n->rcall.params : n->ifcall.params;
src/riscv32/emit_ir.c:383:         ir_node_t* tmp = n->rcall.addr;
src/riscv32/emit_ir.c:395:         emit("call %s", n->ifcall.name);
src/riscv32/emit_ir.c:400:      return n->next;
src/riscv32/emit_ir.c:425:      if (n->binary.b.type == IRT_UINT && n->binary.a.type == IRT_REG) {
src/riscv32/emit_ir.c:426:         av = n->binary.b;
src/riscv32/emit_ir.c:427:         bv = n->binary.a;
src/riscv32/emit_ir.c:429:         av = n->binary.a;
src/riscv32/emit_ir.c:430:         bv = n->binary.b;
src/riscv32/emit_ir.c:436:      dest = reg_op(n->binary.dest);
src/riscv32/emit_ir.c:460:      return n->next;
src/riscv32/emit_ir.c:465:      panic("unsupported ir_node type '%s'", ir_node_type_str[n->type]);
src/riscv32/emit_ir.c:467:   panic("unreachable reached, n->type='%s'", ir_node_type_str[n->type]);
src/irgen.c:12:   n->type = t;
src/irgen.c:13:   n->prev = n->next = NULL;
src/irgen.c:62:      idx = scope_find_var_idx(scope, &n->lookup.scope, e->str);
src/irgen.c:71:                  n->type = IR_GLOOKUP;
src/irgen.c:72:                  n->lstr.str = e->str;
src/irgen.c:73:                  n->lstr.reg = creg++;
src/irgen.c:76:                  n->type = IR_LOAD;
src/irgen.c:77:                  n->load.dest = creg++;
src/irgen.c:78:                  n->load.value = cunit.constants[sym.idx].value;
src/irgen.c:79:                  n->load.size = IRS_INT;
src/irgen.c:83:                  n->type = IR_FLOOKUP;
src/irgen.c:84:                  n->lstr.str = e->str;
src/irgen.c:85:                  n->lstr.reg = creg++;
src/irgen.c:92:               n->type = IR_FLOOKUP;
src/irgen.c:93:               n->lstr.str = e->str;
src/irgen.c:94:               n->lstr.reg = creg++;
src/irgen.c:99:            n->type = IR_FPARAM;
src/irgen.c:100:            n->fparam.reg = creg++;
src/irgen.c:101:            n->fparam.idx = idx;
src/irgen.c:104:         n->lookup.reg = creg++;
src/irgen.c:105:         n->lookup.var_idx = idx;
src/irgen.c:106:         const struct value_type* vt = n->lookup.scope->vars[n->lookup.var_idx].type;
src/irgen.c:148:      n->load.dest = creg++;
src/irgen.c:149:      n->load.value = e->uVal;
src/irgen.c:150:      n->load.size = irs;
src/irgen.c:154:      n->load.dest = creg++;
src/irgen.c:155:      n->load.value = e->uVal;
src/irgen.c:156:      n->load.size = IRS_CHAR;
src/irgen.c:381:      n->rcall.addr = ir_expr(scope, e->fcall.func);
src/irgen.c:383:      n->rcall.dest = creg;
src/irgen.c:384:      n->rcall.params = NULL;
src/irgen.c:385:      n->rcall.variadic = func->func.variadic;
src/irgen.c:399:         buf_push(n->rcall.params, optim_ir_nodes(ir));
src/irgen.c:407:      n->lstr.reg = creg++;
src/irgen.c:408:      n->lstr.str = e->str;
src/irgen.c:522:      n->load.dest = creg++;
src/irgen.c:531:            n->lookup.reg = creg - 1;
src/irgen.c:532:            if ((n->lookup.var_idx = scope_find_var_idx(scope, &n->lookup.scope, t->str)) == SIZE_MAX)
src/irgen.c:535:         } else n->load.value = sizeof_value(nvt, false);
src/irgen.c:536:      } else n->load.value = sizeof_value(e->szof.type, false);
src/irgen.c:537:      n->load.size = IRS_INT;
src/irgen.c:556:      n->lstr.reg = creg++;
src/irgen.c:557:      n->lstr.str = strint(buffer);
src/irgen.c:574:         n->lookup.reg = creg++;
src/irgen.c:575:         if ((n->lookup.var_idx = scope_find_var_idx(scope, &n->lookup.scope, t->str)) == SIZE_MAX)
src/irgen.c:588:         n->load.dest = creg++;
src/irgen.c:589:         n->load.value = nvt->pointer.array.size;
src/irgen.c:590:         n->load.size = IRS_INT;
src/irgen.c:640:      n->scope = s->scope;
src/irgen.c:774:      n->str = begin;
src/irgen.c:813:      n->str = begin_loop;
src/irgen.c:835:      n->str = end_loop;
src/irgen.c:840:      n->str = begin_loop;
src/irgen.c:912:   n->func = f;
src/ir.c:78:   while (n->next) n = n->next;
src/ir.c:96:   n->prev = b;
src/ir.c:104:      n = n->next;
src/ir.c:112:      n = n->next;
src/ir.c:116:   fputs(ir_node_type_str[n->type], file);
src/ir.c:117:   switch (n->type) {
src/ir.c:129:      fprintf(file, ".%s R%u, R%u", ir_size_str[n->move.size], n->move.dest, n->move.src);
src/ir.c:132:      fprintf(file, ".%s R%u, %ju", ir_size_str[n->load.size], n->load.dest, n->load.value);
src/ir.c:158:      fprintf(file, ".%s R%u, ", ir_size_str[n->binary.size], n->binary.dest);
src/ir.c:159:      print_ir_value(file, &n->binary.a);
src/ir.c:161:      print_ir_value(file, &n->binary.b);
src/ir.c:167:      fprintf(file, ".%s R%u", ir_size_str[n->unary.size], n->unary.reg);
src/ir.c:171:      fprintf(file, " R%u, %s", n->lookup.reg, n->lookup.scope->vars[n->lookup.var_idx].name);
src/ir.c:174:      fprintf(file, ".%s R%u, %s R%u", ir_size_str[n->iicast.ds], n->iicast.dest, ir_size_str[n->iicast.ss], n->iicast.src);
src/ir.c:177:      fprintf(file, " %s, R%u", n->ifcall.name, n->ifcall.dest);
src/ir.c:178:      /*for (size_t i = 0; i < buf_len(n->ifcall.params); ++i)
src/ir.c:179:         fprintf(file, ", R%u", n->ifcall.params[i]);
src/ir.c:183:      fprintf(file, "%s", n->ifcall.name);
src/ir.c:187:      fprintf(file, " R%u, %s", n->fparam.reg, n->func->params[n->fparam.idx].name);
src/ir.c:190:      fprintf(file, " R%u, '%s'", n->lstr.reg, n->lstr.str);
src/ir.c:194:      fprintf(file, " R%u, %s", n->lstr.reg, n->lstr.str);
src/ir.c:197:      fprintf(file, " %s", n->str);
src/ir.c:201:      fprintf(file, ".%s %s, R%u", ir_size_str[n->cjmp.size], n->cjmp.label, n->cjmp.reg);
src/ir.c:204:      fprintf(file, "%s:", n->str);
src/ir.c:207:      fprintf(file, " R%u, ", n->alloca.dest);
src/ir.c:208:      print_ir_value(file, &n->alloca.size);
src/ir.c:211:      fprintf(file, " R%u, R%u, %ju", n->copy.dest, n->copy.src, n->copy.len);
src/ir.c:214:      fprintf(file, " R%u", n->rcall.dest);
src/ir.c:233:   if (n->type == IR_IFCALL || n->type == IR_FCALL) {
src/ir.c:234:      for (size_t i = 0; i < buf_len(n->ifcall.params); ++i)
src/ir.c:235:         free_ir_nodes(n->ifcall.params[i]);
src/ir.c:236:      buf_free(n->ifcall.params);
src/ir.c:237:   } else if (n->type == IR_IRCALL || n->type == IR_RCALL) {
src/ir.c:238:      for (size_t i = 0; i < buf_len(n->rcall.params); ++i)
src/ir.c:239:         free_ir_nodes(n->rcall.params[i]);
src/ir.c:240:      free_ir_nodes(n->rcall.addr);
src/ir.c:246:      ir_node_t* next = n->next;
src/ir.c:252:   if (n->prev) n->prev->next = n->next;
src/ir.c:253:   if (n->next) n->next->prev = n->prev;
src/ir.c:257:   return n && n->type == t;
src/ir.c:268:      else if (t == n->type) {
src/ir.c:279:   if (ir_is_binary(n->type))
src/ir.c:280:      return n->binary.dest;
src/ir.c:282:   switch (n->type) {
src/ir.c:285:      return n->move.dest;
src/ir.c:287:      return n->load.dest;
src/ir.c:289:      return n->iicast.dest;
src/ir.c:291:      return n->ifcall.dest;
src/ir.c:293:      return n->rcall.dest;
src/ir.c:296:      return n->lstr.reg;
src/ir.c:299:      return n->lookup.reg;
src/ir.c:301:      return n->fparam.reg;
src/ir.c:307:   if (ir_is_binary(n->type))
src/ir.c:308:      return (n->binary.a.type == IRT_REG && n->binary.a.reg == r)
src/ir.c:309:         ||  (n->binary.b.type == IRT_REG && n->binary.b.reg == r);
src/ir.c:310:   switch (n->type) {
src/ir.c:312:   case IR_MOVE:  return n->move.src == r;
src/ir.c:313:   case IR_WRITE: return n->move.dest == r;
src/ir.c:318:      return n->unary.reg == r;
src/ir.c:320:      return n->iicast.src == r;
src/ir.c:322:      return n->alloca.size.type == IRT_REG && n->alloca.size.reg == r;
src/ir.c:324:      return n->copy.src == r || n->copy.dest == r;
src/vtype.c:593:      if (tmp->type != VAL_POINTER) parse_error(&e->expr->begin, "cannot dereference a non-pointer");
src/vtype.c:869:            warn_implicit("const pointer", "non-const pointer");
include/stmt.h:10:   STMT_EXPR,        // .expr       | simple expression-statement
include/ir.h:63:   IR_FCALL,         // .ifcall     | function call w/ return-type void
.git/hooks/pre-commit.sample:5:# exit with non-zero status after issuing an appropriate message if
.git/hooks/pre-commit.sample:18:# If you want to allow non-ASCII filenames set this variable to true.
.git/hooks/pre-commit.sample:24:# Cross platform projects tend to avoid non-ASCII filenames; prevent
.git/hooks/pre-commit.sample:35:Error: Attempt to add a non-ASCII file name.
.git/hooks/prepare-commit-msg.sample:7:# message file.  If the hook fails with a non-zero status,
.git/hooks/prepare-commit-msg.sample:38:# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
.git/hooks/push-to-checkout.sample:23:# It can exit with a non-zero status to refuse the push (when it does
.git/hooks/pre-merge-commit.sample:5:# exit with non-zero status after issuing an appropriate message to
.git/hooks/applypatch-msg.sample:6:# The hook should exit with non-zero status after issuing an
.git/hooks/pre-push.sample:5:# pushed.  If this script exits with a non-zero status nothing will be pushed.
.git/hooks/update.sample:72:		# un-annotated tag
.git/hooks/update.sample:75:			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
.git/hooks/commit-msg.sample:5:# that has the commit message.  The hook should exit with non-zero
.git/hooks/fsmonitor-watchman.sample:57:	# open (my $fh, ">", ".git/watchman-output.out");
.git/hooks/fsmonitor-watchman.sample:101:	# open (my $fh, ">", ".git/watchman-query.json");
.git/hooks/fsmonitor-watchman.sample:110:	# open ($fh, ">", ".git/watchman-response.json");
.git/hooks/fsmonitor-watchman.sample:136:		# open (my $fh, ">", ".git/watchman-output.out");
.git/hooks/pre-applypatch.sample:6:# The hook should exit with non-zero status after issuing an
.git/hooks/pre-rebase.sample:7:# non-zero status.
